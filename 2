/// QUBO start heuristic enum

use crate::qubo::*;
use ndarray_stats::QuantileExt;

/// Computes the "sum cross" of x^T@Q@x for index k efficiently: O(n)
fn compute_sum_cross(mat: &Matrix, x: &BinaryVector, k: usize) -> Float {
    let mut y = Vector::zeros(x.len());
    for i in 0..x.len() {
        y[i] = x[i] as u8 as Float;
    }
    compute_sum_cross_float(mat, &y, k)
}

/// Computes the "sum cross" of x^T@Q@x for index k efficiently: O(n)
fn compute_sum_cross_float(mat: &Matrix, x: &Vector, k: usize) -> Float {
    assert!(k <= mat.nrows());
    let xk = x[k];
    let mut sum_cross = 0.0;
    for i in 0..k {
        let xi = x[i]; // false => 0, true => 1
        sum_cross += mat[[i, k]]*xi*xk;
        sum_cross += mat[[k, i]]*xi*xk;
    }
    sum_cross + mat[[k, k]]*xk*xk
}

/// Cast Vector (Float) to BinaryVector (bool)
fn vecf_to_vecb(x: Vector) -> BinaryVector {
    let n = x.len();
    let mut y = BinaryVector::from_vec(vec![false; n]);
    for i in 0..n {
        y[i] = x[i] as u8 != 0;
    }
    y
}

pub enum StartHeuristic {
    Random(),
    GreedyRounding(Float),
}
impl StartHeuristic {
    pub fn get_solution(&self, qubo: &QuboInstance) -> BinaryVector {
        match self {
            StartHeuristic::Random()
                => { StartHeuristic::rand(qubo) },
            StartHeuristic::GreedyRounding(hint)
                => { StartHeuristic::round_greedy(qubo, hint) },
        }
    }

    /// Return a random start solution
    fn rand(qubo: &QuboInstance) -> BinaryVector {
        todo!()
    }

    /// Find best rounding at some index until all indices are rounded
    fn round_greedy(qubo: &QuboInstance, hint: &Float) -> BinaryVector {
        let n = qubo.size();
        let mat = qubo.get_matrix();
        let mut hint_vec = Vector::from_vec(vec![*hint; n]);
        // Changes on round of entry:
        let mut dx_on_round = Matrix::from_shape_vec((2, n), vec![0.0; n])
        let mut dx_on_rup = Vector::from_vec(vec![0.0; n]);
        let mut dx_on_rdn = Vector::from_vec(vec![0.0; n]);
        // Compute initial dx
        for i in 0..n {
            // Round down
            hint_vec[k] = 0.0;
            dx_on_round[[0, i]] = compute_sum_cross_float(mat, &hint_vec, i);
            // Round up
            hint_vec[k] = 1.0;
            dx_on_round[[1, i]] = compute_sum_cross_float(mat, &hint_vec, i);
            // Undo rounding
            hint_vec[k] = *hint;
        }
        for _ in 0..n {
            // let mut best_k  = 0;
            // let mut best_dx = Float::MAX;
            // let mut best_is_rup = false; // is round up or round down
            // for k in unvisited {
            //     let (dx, k_is_rup) = match dx_on_rup[k] < dx_on_rdn[k] {
            //         true  => (dx_on_rup[k], true),
            //         false => (dx_on_rdn[k], false),
            //     }
            //     if best_dx <= dx { continue; }
            //     // Set new current best
            //     best_k = k;
            //     best_dx = dx;
            //     best_is_rup = k_is_rup;
            // }
            // Find next best up/down rounding (for biggest downward dx)
            let (i, j) = dx_on_round.argmin().unwrap();
            if i == 1 {
                // Round up
                hint_vec[j] = 1.0;
            }
            else {
                // Round down
                hint_vec[j] = 0.0;
            }
            dx_on_round[[i, j]] = Float::MAX;
            // Update dx
            for i in 0..n {
                //dx_on_rup[k] = compute_sum_cross_float(mat, &hint_vec, k);
                dx_on_rup[i] -= mat[[]];
                // update the diff on round down of hint_vec[k]
                hint_vec[k] = 0.0;
                dx_on_rdn[k] = compute_sum_cross_float(mat, &hint_vec, k);
                // Reset hint_vec[k]
                hint_vec[k] = *hint;
            }
        }
        // Cast hint_vec to BinaryVector
        vecf_to_vecb(hint_vec)
    }
}

#[cfg(test)]
mod tests {
    use crate::qubo::*;
    use crate::start_heuristics::*;

    #[test]
    fn test_sum_cross() {
        let x = BinaryVector::from_vec(vec![true, false, true]);
        let matrix = Matrix::from_shape_vec((3,3),
            vec![1.0, 2.0, 3.0, 0.0, 4.0, 5.0, 0.0, 0.0, 6.0,]).unwrap();
        let mut obj_val = 0.0;
        for i in 0..matrix.nrows() {
            obj_val += compute_sum_cross(&matrix, &x, i);
        }
        assert_eq!(10.0, obj_val);
    }

    #[test]
    fn test_greedy_rounding() {
        let x = BinaryVector::from_vec(vec![true, false, true]);
        let matrix = Matrix::from_shape_vec((3,3),
            vec![1.0, 2.0, 3.0, 0.0, 4.0, 5.0, 0.0, 0.0, 6.0,]).unwrap();
        let qubo = QuboInstance::new(matrix, 0.0);
        todo!();
    }
}
